global:全局变量，作用于是整个模块，整个文件内的代码段
这个东西尽量好好访问，不要修改
如果试图修改，那么python只是会偷偷创造一个同名的局部变量
专业点说叫 屏蔽
如果真的十分想改，用global改，用global重新定义同名变量，然后改

内嵌函数：
函数里边可以嵌函数
当内部函数整个作用域都在外部函数之内的时候
（比如定义就在另外一个函数里头）
那么你在外边就永远不能调用这个函数了
他会说你没有def

闭包：
def funX(x):
    def funY(y):
        return x*y
    return FunY

内嵌函数用自己的环境中的变量，也用输入的变量，不用全局变量

类似于， i = funX(8)
那么i就是一个函数类型的变量
具体来说i(y)返回的是8y
比如说i(5) = 40
或者也可以表示为FunX(8)(5) = 40
但是你从外边是不能搞到FunY的

外部函数的局部变量对内部函数的局部变量的关系
类似于全局变量相对于局部变量的关系
相当于函数的函数那种感觉，返回值是一个函数

另外要注意的是，因为上边的原因，那么内嵌函数是不能对已经设定好的外部函数的局部变量进行修改
因为对于内嵌函数来说，那个是个全局变量

字符串列表数组实际上都是容器类型
(python3之前)
所以一个解决方案是可以用x[]之类的
因为容器类型不存在栈里，不会受到全局变量的限制
所以可以用局部变量设置为x=[5],内部函数用x[0]强行访问

python3之后，新的方案是，用nonlocal
相当于局部变量里用global的感觉
nonlocal就是冲出去干掉(引用)相对于内嵌函数的全局变量（也就是那个狐假虎威的局部变量）hhh
不过好像nonlocal并不会像global那样子对外边的变量进行修改
他仿佛只是悄悄地创了个重名的